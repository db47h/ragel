//go:generate go run ./cmd/unicode2ragel -cat Letter -o utf8.rl -m UTF8
//go:generate ragel -Z -G2 lang_test.rl -o lang_test.go
//go:generate sed -i "1s|.*|// Code generated by ragel. DO NOT EDIT.|" lang_test.go

package ragel_test

import (
	"fmt"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/db47h/ragel/v2"
)

func TestNext(t *testing.T) {
	input := "\x88a = 4;\nçcc = xyz + 17.0\n'x'\n\x81"
	r := strings.NewReader(input)
	l := ragel.New("", r, stub{})

	res := []struct {
		pos string
		typ ragel.Token
		lit string
	}{
		{":1:1", ragel.Error, "invalid character U+0088"},
		{":1:2", Ident, "a"},
		{":1:4", Symbol, "="},
		{":1:6", Int, "4"},
		{":1:7", Symbol, ";"},
		{":2:1", Ident, "çcc"},
		{":2:6", Symbol, "="},
		{":2:8", Ident, "xyz"},
		{":2:12", Symbol, "+"},
		{":2:14", Float, "17.0"},
		{":3:1", Char, "'x'"},
		{":4:1", ragel.Error, "invalid character U+0081"},
		{":4:2", ragel.EOF, "EOF"},
		{":4:2", ragel.EOF, "EOF"},
	}

	for i := 0; i < len(res); i++ {
		offset, tok, lit := l.Next()
		e := fmt.Sprintf("%s: %v %v", res[i].pos, res[i].typ, res[i].lit)
		g := fmt.Sprintf("%s: %v %v", l.Pos(offset), tok, lit)
		if g != e {
			t.Errorf("Expected %q, got %q", e, g)
		}
	}
}

func BenchmarkNext(b *testing.B) {
	input := "a = 4; çcc := xyz + 17\n"
	r := strings.NewReader(input)
	l := ragel.New("INPUT", r, stub{})
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		l.Reset()
	Loop:
		for {
			o, tok, v := l.Next()
			switch tok {
			case ragel.Error:
				b.Fatalf("parse failed: %s: %s", l.Pos(o), v)
				fallthrough
			case ragel.EOF:
				break Loop
			}
		}
	}
}

func BenchmarkNext_largeishFile(b *testing.B) {
	r, err := os.Open("testdata/lang_test.go")
	if err != nil {
		b.Fatal(err)
	}
	fi, err := r.Stat()
	if err != nil {
		b.Fatal(err)
	}
	l := ragel.New("INPUT", r, stub{}, ragel.BufferSize(int(fi.Size())))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		l.Reset()
	Loop:
		for {
			o, tok, v := l.Next()
			switch tok {
			case ragel.Error:
				b.Fatalf("parse failed: %s: %s", l.Pos(o), v)
				fallthrough
			case ragel.EOF:
				break Loop
			}
		}
	}
}

func Test_issues(t *testing.T) {
	type tok struct {
		off int
		tok ragel.Token
		lit string
	}
	tests := map[string]struct {
		file string
		in   io.Reader
		opts []ragel.Option
		exp  []tok
	}{
		"5_string": {
			in:   strings.NewReader("42"),
			opts: []ragel.Option{ragel.BufferSize(2)},
			exp: []tok{
				{0, Int, "42"},
				{2, ragel.EOF, "EOF"},
			},
		},
		"5_file": {
			file: "testdata/issues/issue5.input",
			opts: []ragel.Option{ragel.BufferSize(2)},
			exp: []tok{
				{0, Int, "42"},
				{2, ragel.EOF, "EOF"},
			},
		},
		"6_with_handler": {
			in: strings.NewReader("'"),
			exp: []tok{
				{0, ragel.Error, "non-terminated single-quote"},
				{1, ragel.EOF, "EOF"},
			},
		},
		"6_large_buffer": {
			in: strings.NewReader("\""),
			exp: []tok{
				{0, ragel.Error, "non-terminated token: unexpected EOF"},
				{1, ragel.EOF, "EOF"},
			},
		},
		"6_short_buffer": {
			in:   strings.NewReader("\""),
			opts: []ragel.Option{ragel.BufferSize(1)},
			exp: []tok{
				{0, ragel.Error, "non-terminated token: unexpected EOF"},
				{1, ragel.EOF, "EOF"},
			},
		},
		"6_invalid_char": {
			in: strings.NewReader("'\x81"),
			exp: []tok{
				{0, ragel.Error, "non-terminated single-quote"},
				{2, ragel.EOF, "EOF"},
			},
		},
	}
	for n, issue := range tests {
		t.Run(fmt.Sprintf("#%s", n), func(t *testing.T) {
			var (
				fn string
				in io.Reader
			)
			if issue.file != "" {
				f, err := os.Open(issue.file)
				if err != nil {
					t.Fatal(err)
				}
				defer f.Close()
				fn = issue.file
				in = f
			} else {
				fn = "string"
				in = issue.in
			}
			s := ragel.New(fn, in, stub{}, issue.opts...)
			for _, e := range issue.exp {
				off, tok, lit := s.Next()
				if off != e.off || tok != e.tok || lit != e.lit {
					t.Fatalf("Expected %s: %d %q. Got: %s: %d %q", s.Pos(e.off), e.tok, e.lit, s.Pos(off), tok, lit)
				}
			}
		})
	}
}
